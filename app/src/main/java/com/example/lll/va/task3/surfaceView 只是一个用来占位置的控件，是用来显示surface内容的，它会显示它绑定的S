surfaceView 只是一个用来占位置的控件，是用来显示surface内容的，它会显示它绑定的SurfaceHolder所持有的surface， 真正用于显示的是surface(它是具体的要显示的数据)，surface的持有者是SurfaceHolder，每个surfaceView生来就有一个默认与其绑定的SurfaceHolder，通过getHolder来获取，SurfaceHolder会决定如何去显示surface，每个surface有且只有一个SurfaceHolder，
surfaceView:画布
surface：画的内容
surfaceHolder，画内容的持有者
surfaceView、surfaceHolder、surface三位一体，是一个不可分的整体

/*
一个camera设置好参数，让它持有本后，它本身是被本线程持有的，持有的话是被lock的，mediaRecorder的工作是在单独的线程中完成的
使用setCamera给mediarecorder设置一个被设置好相机。而如果不调用setCamera设置相机的话，分配给的是一个默认情况下的相机，也就是说什么参数都没有被设置，这样一般不可能满足拍摄需求，因此一般要给mediaRecorder设置camera

在mediaRecorder.start之前，它的camera必须要调用unlock(如果设置了的话)，因为mediaRecorder的工作是在单独的线程中完成的，而camera默认是被创建它的线程所持有的，这样mediaRecorder的工作线程无法使用它)，如果start顺利结束，则会自动调用lock归还camera，如果start调用失败，则要手动lock来回收camera的所有权



mediaRecorder.setPreviewDisplay(Surface s) 给mediaRecorder设置surface，surface是用来显示mediaRecorder的相机的预览。
如果s已经被一个设置给了camera（只是设置给了，还没有被持有资源），而且这个camera已经通过mediaRecorder.setCamera被设置给了mediaRecorder，那么这个方法不需要调用。
如果s已经被设置给了一个另一个camera只是设置给了，还没有被持有资源），但这个camera没有被设置给mediaRecorder，那么这个s将会被设置给给mediaRecorder自己的camera（如果没设置，则是默认的camera）。此时mediaRecorder自己的camera和另一个camera被设置了同一个surface.
如果s为空，则完全不会发生任何事

camera.setHolder  给camera设置一个holder，即surface；但此时holder的surface资源并不为camera所持有，只有当开启预览(即startPreview)时，surface资源才会被camera所持有（下面所说的surface和相应的surfaceHolder都是绑定的，彼此一体，surface资源也就相当于holder的资源）

如果对一个camera持有一个surface的资源，再次让另一个camera持有再次去持有这个surface资源，则会报错(mediaRecorder.start中会调用它自己的camera.startPreview,startPreview会试图去占有surface资源)也就是说，同一个surfaceHolder可以被多个camera设置，但同时只能有一个camera持有它的surface的资源，否则就会报错。可以对同一个camera连续多次试图持有资源（反正资源就是你的，反复持有还是这些）. 当用startPreview成功开启预览后,surface的资源就被camera持有，此时单纯调用stopPreview关闭预览并不能释放它所持有的surface资源，必须要用camera.release(完全释放camera)，或者直接setDisplayHolder（null）（只释放camera占有的surface资源，不改变camera的其他参数设置）才能释放它占用的surface资源。但不能直接把camera置为null来释放资源，因为这样只能减少它的引用计数，不是真正的释放资源。


mediaRecorder 不会吧自己的surface主动连接到自己设置的camera, 除非是不设置camera而使用默认的camera，因为mediaRecorder会默认自己设置的camera有surface

camera.setDisplayOrientation设置相机预览的角度，mediaRecorder.setOrientationHini设置存储的视频的角度，两者互相独立